<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å¯å†…æ‹–æ‹¼å›¾æ¸¸æˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #f8fafc; padding: 2rem; font-family: 'Inter', sans-serif; }
        .container { max-width: 1200px; margin: 0 auto; }
        .upload-btn {
            padding: 12px 24px;
            background: #2563eb;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.3s;
            display: inline-block;
            margin-bottom: 2rem;
        }
        .upload-btn:hover { background: #1d4ed8; }
        .game-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        .section {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        .puzzle-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px; /* ä¼˜åŒ–1ï¼šç¼©å°ç¼éš™ä¸º4px */
        }
        .puzzle-piece {
            cursor: move;
            transition: 0.3s;
            background-size: cover;
            background-repeat: no-repeat;
            border: 2px solid transparent;
        }
        .puzzle-piece.dragging {
            opacity: 0.7;
            transform: scale(0.98);
            border-color: #2563eb;
        }
        .target-placeholder {
            background: #f8fafc;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #94a3b8;
            font-size: 0.875rem;
        }
        .correct-position {
            border-color: #22c55e;
            box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <input type="file" id="uploadInput" accept="image/*" hidden>
        <label for="uploadInput" class="upload-btn">ä¸Šä¼ 1:1æ¯”ä¾‹å›¾ç‰‡å¼€å§‹æ¸¸æˆ</label>
        <div class="game-grid">
            <div class="section">
                <h3 class="title">æ‰“ä¹±çš„æ‹¼å›¾</h3>
                <div class="puzzle-container" id="puzzleGrid"></div>
            </div>
            <div class="section">
                <h3 class="title">ç›®æ ‡åŒºåŸŸ</h3>
                <div class="puzzle-container" id="targetGrid"></div>
            </div>
        </div>
    </div>

    <script>
        const uploadInput = document.getElementById('uploadInput');
        const puzzleGrid = document.getElementById('puzzleGrid');
        const targetGrid = document.getElementById('targetGrid');
        let sourceImage = null;
        let pieces = [];  // å­˜å‚¨æ‰€æœ‰æ‹¼å›¾å—ä¿¡æ¯ {element, correctIndex}

        uploadInput.addEventListener('change', handleImageUpload);

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file || !file.type.startsWith('image/')) {
                alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    if (img.width !== img.height) {
                        alert('è¯·ä¸Šä¼ 1:1æ¯”ä¾‹çš„å›¾ç‰‡ï¼');
                        return;
                    }
                    sourceImage = img;
                    initializeGame(img.width);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function initializeGame(imgSize) {
            const pieceSize = imgSize / 3;
            pieces = [];

            // æ¸…ç©ºå®¹å™¨
            puzzleGrid.innerHTML = '';
            targetGrid.innerHTML = '';

            // è®¾ç½®å®¹å™¨å°ºå¯¸å’Œç¼éš™
            [puzzleGrid, targetGrid].forEach(container => {
                container.style.gridTemplateColumns = `repeat(3, ${pieceSize}px)`;
                container.style.gap = `${pieceSize * 0.04}px`; // åŠ¨æ€è®¡ç®—ç¼éš™ï¼ˆå—å°ºå¯¸çš„4%ï¼‰
            });

            // ç”Ÿæˆç›®æ ‡åŒºåŸŸå ä½å—
            Array.from({ length: 9 }, (_, i) => i).forEach(targetIndex => {
                const placeholder = document.createElement('div');
                placeholder.className = `puzzle-piece target-placeholder`;
                placeholder.style.width = `${pieceSize}px`;
                placeholder.style.height = `${pieceSize}px`;
                placeholder.dataset.targetIndex = targetIndex;
                placeholder.textContent = `ä½ç½®${targetIndex + 1}`;
                targetGrid.appendChild(placeholder);
                setupDropZone(placeholder); // è®¾ç½®å¯æ”¾ç½®åŒºåŸŸ
            });

            // ç”Ÿæˆæ‰“ä¹±çš„æ‹¼å›¾å—
            const correctPositions = Array.from({ length: 9 }, (_, i) => i);
            const shuffledPositions = [...correctPositions].sort(() => Math.random() - 0.5);
            
            shuffledPositions.forEach((correctIndex, currentIndex) => {
                const piece = createPuzzlePiece(pieceSize, correctIndex, imgSize);
                piece.dataset.source = 'puzzle'; // æ ‡è®°æ¥æºä¸ºæ‹¼å›¾åŒº
                piece.addEventListener('dragstart', handleDragStart);
                piece.addEventListener('dragend', handleDragEnd);
                puzzleGrid.appendChild(piece);
                pieces.push(piece);
            });
        }

        // åˆ›å»ºæ‹¼å›¾å—çš„é€šç”¨å‡½æ•°
        function createPuzzlePiece(pieceSize, correctIndex, imgSize) {
            const piece = document.createElement('div');
            piece.className = 'puzzle-piece';
            piece.draggable = true;
            piece.style.width = `${pieceSize}px`;
            piece.style.height = `${pieceSize}px`;
            piece.dataset.correctIndex = correctIndex;

            // è®¡ç®—åˆ‡ç‰‡ä½ç½®
            const x = (correctIndex % 3) * pieceSize;
            const y = Math.floor(correctIndex / 3) * pieceSize;
            piece.style.backgroundImage = `url(${sourceImage.src})`;
            piece.style.backgroundPosition = `-${x}px -${y}px`;
            piece.style.backgroundSize = `${imgSize}px ${imgSize}px`;

            // éšæœºæ—‹è½¬
            const rotation = [0, 90, 180, 270][Math.floor(Math.random() * 4)];
            piece.style.transform = `rotate(${rotation}deg)`;
            piece.dataset.rotation = rotation;

            // ç‚¹å‡»æ—‹è½¬
            piece.addEventListener('click', () => {
            let rot = parseInt(piece.dataset.rotation) || 0;
            rot = (rot + 90) % 360;
            piece.style.transform = `rotate(${rot}deg)`;
            piece.dataset.rotation = rot;
            
            // ç«‹å³è§¦å‘æ­£ç¡®æ€§æ£€æŸ¥
            if (piece.dataset.source === 'target') {
                const targetIndex = Array.from(targetGrid.children).indexOf(piece);
                checkPiecePosition(piece, targetIndex);
            }
        });

            return piece;
        }

        // æ‹–æ‹½å¼€å§‹å¤„ç†
        function handleDragStart(e) {
            e.dataTransfer.setData('text/plain', JSON.stringify({
                index: Array.from(this.parentElement.children).indexOf(this),
                source: this.dataset.source
            }));
            this.classList.add('dragging');
        }

        // æ‹–æ‹½ç»“æŸå¤„ç†
        function handleDragEnd() {
            this.classList.remove('dragging');
        }

        // è®¾ç½®å¯æ”¾ç½®åŒºåŸŸçš„äº‹ä»¶
        function setupDropZone(zone) {
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                zone.style.backgroundColor = '#eff6ff';
            });

            zone.addEventListener('dragleave', () => {
                zone.style.backgroundColor = '';
            });

            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.style.backgroundColor = '';
                const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
                const sourceElement = dragData.source === 'puzzle' 
                    ? puzzleGrid.children[dragData.index] 
                    : targetGrid.children[dragData.index];

                // å…è®¸ç›®æ ‡åŒºåŸŸå†…æ‹–æ‹½äº¤æ¢ï¼ˆä¿®å¤åçš„æ ¸å¿ƒé€»è¾‘ï¼‰
                if (dragData.source === 'target') {
                    const draggedElement = sourceElement;
                    const targetZone = zone;

                    // åˆ›å»ºä¸´æ—¶å ä½ç¬¦è¿›è¡Œäº¤æ¢
                    const temp = document.createElement('div');
                    targetZone.replaceWith(temp);
                    draggedElement.replaceWith(targetZone);
                    temp.replaceWith(draggedElement);
                    temp.remove();
                } else {
                    zone.replaceWith(sourceElement);
                    sourceElement.dataset.source = 'target';
                    sourceElement.addEventListener('dragstart', handleDragStart);
                }

                // æ£€æŸ¥ä½ç½®æ˜¯å¦æ­£ç¡®
                checkPiecePosition(sourceElement, zone.dataset.targetIndex);
            });
        }

        // æ£€æŸ¥æ‹¼å›¾å—ä½ç½®æ˜¯å¦æ­£ç¡®
        function checkPiecePosition(piece, targetIndex) {
        const isPositionCorrect = piece.dataset.correctIndex === targetIndex;
        const isRotationCorrect = parseInt(piece.dataset.rotation) === 0; // å¿…é¡»0åº¦æ‰ç®—æ­£ç¡®
        const isFullyCorrect = isPositionCorrect && isRotationCorrect;

        piece.classList.toggle('correct-position', isFullyCorrect); // ä»…å½“ä½ç½®å’Œæ—‹è½¬éƒ½æ­£ç¡®æ—¶æ ‡è®°

        // æ£€æŸ¥æ•´ä½“å®Œæˆåº¦æ—¶åŒæ—¶éªŒè¯æ—‹è½¬
        const allCorrect = Array.from(targetGrid.children).every(child => {
            const correctIndexMatch = child.dataset.correctIndex === child.parentElement.dataset.targetIndex;
            const rotationMatch = parseInt(child.dataset.rotation) === 0;
            return correctIndexMatch && rotationMatch;
        });

            if (allCorrect) {
                alert('ğŸ‰ æ­å–œï¼æ‰€æœ‰æ‹¼å›¾å½’ä½æˆåŠŸï¼');
                // è‡ªåŠ¨æ—‹è½¬å›0åº¦
                targetGrid.querySelectorAll('.puzzle-piece').forEach(piece => {
                    piece.style.transform = 'rotate(0deg)';
                    piece.dataset.rotation = 0;
                });
            }
        }
    </script>
